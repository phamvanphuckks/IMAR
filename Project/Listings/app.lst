C51 COMPILER V9.60.0.0   APP                                                               03/13/2023 07:43:08 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE APP
OBJECT MODULE PLACED IN .\Objects\app.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\app.c OPTIMIZE(7,SPEED) BROWSE INCDIR(.\inc;.\Library\Device\Include
                    -;.\Library\StdDriver\inc;..\Project) DEBUG OBJECTEXTEND PRINT(.\Listings\app.lst) TABS(2) OBJECT(.\Objects\app.obj)

line level    source

   1          #include "app.h"
   2          
   3          /********************************************//**
   4           *   User variables
   5           ***********************************************/
   6          typedef enum {
   7            NORMAL = 1,
   8            PASS_HOLD_3S,
   9            PASS_ALARM_5S
  10          } STATE_t;
  11          
  12          typedef enum {
  13            LOW = 0,
  14            HIGH,
  15          }; 
  16           
  17          static int xdata set_second, set_minute, set_hour, day, wday, month, year;
  18          static RTC_time_t xdata rtc_time;
  19          static RTC_date_t xdata rtc_date;
  20          volatile uint16_t tick;
  21          volatile uint8_t request_ds1307_interval = LOW;
  22          
  23          static STATE_t state = NORMAL;
  24          static state_alram = 0;
  25          
  26          char xdata payLoad[13];
  27          unsigned char index_data = 0;
  28          /********************************************//**
  29           *   User functions
  30           ***********************************************/
  31          void app_init(void)
  32          {
  33   1        MODIFY_HIRC(HIRC_16);
  34   1        
  35   1        // Initialize GPIO
  36   1        GPIO_init();
  37   1        
  38   1        // Initialize UART
  39   1        uart_init();
  40   1        
  41   1        // Initialize delay - timer0
  42   1        Delay_init();
  43   1        
  44   1        /* init */
  45   1        DS1307_Init();
  46   1        
  47   1        rtc_date.day   = MONDAY;
  48   1        rtc_date.date  = 0;
  49   1        rtc_date.month = 0;
  50   1        rtc_date.year  = 0;
  51   1      
  52   1        rtc_time.hours       = 0;
  53   1        rtc_time.minutes     = 0;
  54   1        rtc_time.seconds     = 0;
C51 COMPILER V9.60.0.0   APP                                                               03/13/2023 07:43:08 PAGE 2   

  55   1        rtc_time.time_format = TIME_FORMAT_24HRS;
  56   1        DS1307_Set_Current_Time(&rtc_time);
  57   1        DS1307_Set_Current_Time(&rtc_date);
  58   1        
  59   1        check_btn_last_state();
  60   1      
  61   1        // TIMER1 Init 
  62   1        TIM1_init();
  63   1      }
  64          
  65          void app_process_action(void)
  66          {
  67   1        check_button();
  68   1      
  69   1        check_uart();
  70   1      
  71   1        ds1307();
  72   1      }
  73          
  74          void uart_init(void)
  75          {
  76   1        UART_Open(FREQ_SYS, UART0_Timer3, 9600);
  77   1        ENABLE_UART0_PRINTF;
  78   1        ENABLE_UART0_INTERRUPT;   /* Enable UART0 interrupt */
  79   1        ENABLE_GLOBAL_INTERRUPT;  /* Global interrupt enable */
  80   1        
  81   1        uartFresh();
  82   1      }
  83          
  84          static void check_button(void)
  85          {
  86   1        uint16_t timeout = 0, last_state;
  87   1        
  88   1        if (state == NORMAL)
  89   1        {
  90   2          if(BTN2_PAS == HIGH)
  91   2          {
  92   3            LED_RELAY2 = HIGH;
  93   3            Delay_ms(10);
  94   3            while (BTN2_PAS == HIGH)
  95   3            {
  96   4              if(timeout == 3000)
  97   4              {  
  98   5                LED_RELAY1 = LOW;         
  99   5                LED_RELAY2 = HIGH;
 100   5                state = PASS_HOLD_3S;
 101   5                
 102   5                last_state = Read_APROM_BYTE(STATE_MODE);
 103   5                if( last_state != PASS_HOLD_3S)
 104   5                {
 105   6                  Write_DATAFLASH_BYTE(STATE_MODE, state);
 106   6                }
 107   5              }
 108   4              Delay_ms(1);
 109   4              timeout++;
 110   4            }
 111   3          }
 112   2          else 
 113   2          {
 114   3            LED_RELAY2 = (BTN1_COS == HIGH)? HIGH : LOW;
 115   3          }
 116   2        }
C51 COMPILER V9.60.0.0   APP                                                               03/13/2023 07:43:08 PAGE 3   

 117   1        
 118   1        if (state == PASS_HOLD_3S)
 119   1        {
 120   2          if(BTN2_PAS == HIGH)
 121   2          {
 122   3            LED_RELAY1 = HIGH;
 123   3            Delay_ms(10);
 124   3            
 125   3            timeout = 0;
 126   3            while (BTN2_PAS == HIGH)
 127   3            {
 128   4              if(timeout == 3000)
 129   4              {  
 130   5                LED_RELAY2 = LOW;
 131   5                  
 132   5                LED_RELAY1 = HIGH;
 133   5                Delay_ms(300);
 134   5                LED_RELAY1 = LOW;
 135   5                Delay_ms(300);
 136   5                LED_RELAY1 = HIGH;
 137   5                  
 138   5                state = NORMAL;
 139   5                
 140   5                last_state = Read_APROM_BYTE(STATE_MODE);
 141   5                if( last_state != NORMAL)
 142   5                {
 143   6                  Write_DATAFLASH_BYTE(STATE_MODE, state);
 144   6                }
 145   5              }
 146   4              Delay_ms(1);
 147   4              timeout++;
 148   4            }
 149   3          }
 150   2          else
 151   2          {
 152   3            LED_RELAY1 = 0;
 153   3          }
 154   2        }
 155   1      }
 156          
 157          void check_btn_last_state(void)
 158          {   
 159   1        uint8_t last_state;
 160   1        
 161   1        last_state = Read_APROM_BYTE(STATE_MODE);
 162   1        if(last_state != 0xFF)
 163   1        {
 164   2          state = last_state;
 165   2        }
 166   1        
 167   1        if(state == NORMAL)
 168   1        {
 169   2          LED_RELAY1 = 1;
 170   2          LED_RELAY2 = 0;   
 171   2        } 
 172   1        else if (state == PASS_HOLD_3S)
 173   1        {
 174   2          LED_RELAY1 = 0;
 175   2          LED_RELAY2 = 1;   
 176   2        }
 177   1        else {
 178   2          LED_RELAY1 = 1;
C51 COMPILER V9.60.0.0   APP                                                               03/13/2023 07:43:08 PAGE 4   

 179   2          LED_RELAY2 = 0;
 180   2        }
 181   1      }
 182          
 183          void check_uart(void)
 184          {
 185   1        char xdata header[3], hours[3], minutes[3], seconds[3];
 186   1        
 187   1        if (IsData() == '#')
 188   1        {
 189   2          while(IsAvailable())
 190   2          {
 191   3            payLoad[index_data++] = uartReadByte();
 192   3          }
 193   2          payLoad[index_data] = '\0';
 194   2          // clear buffer
 195   2          uartResetNByte();
 196   2          
 197   2          // parser data
 198   2          parser_data(header, hours, minutes, seconds, payLoad);
 199   2          
 200   2          if(!strcmp(header, "$C"))
 201   2          {
 202   3            rtc_time.hours       = atoi(hours);
 203   3            rtc_time.minutes     = atoi(minutes);
 204   3            rtc_time.seconds     = atoi(seconds);
 205   3            DS1307_Set_Current_Time(&rtc_time);
 206   3            UART_Send_Data(UART0, 'C');
 207   3          }
 208   2          else if (!strcmp(header, "$S"))
 209   2          {
 210   3            set_second = atoi(seconds);
 211   3            set_minute = atoi(minutes);
 212   3            set_hour = atoi(hours);
 213   3            
 214   3            state_alram = 1;
 215   3            Delay_ms(10);
 216   3            UART_Send_Data(UART0, 'S');
 217   3          }
 218   2          else if (!strcmp(header, "$E"))
 219   2          {
 220   3            
 221   3            UART_Send_Data(UART0, 'E');
 222   3          }
 223   2          else
 224   2          {
 225   3            
 226   3          }
 227   2          
 228   2          // clear buffer
 229   2          index_data = 0;
 230   2          memset(payLoad, 0, 13);
 231   2        }
 232   1      }
 233          
 234          void ds1307(void)
 235          {
 236   1        if((request_ds1307_interval == HIGH) && (state_alram == 1))
 237   1        {
 238   2          DS1307_Get_Current_Time(&rtc_time);
 239   2          UART_Send_Data(UART0, 'I');
 240   2          Delay_ms(10);
C51 COMPILER V9.60.0.0   APP                                                               03/13/2023 07:43:08 PAGE 5   

 241   2          if(rtc_time.hours >= set_hour)
 242   2          {
 243   3            UART_Send_Data(UART0, 'X');
 244   3            Delay_ms(10);
 245   3            if(rtc_time.minutes >= set_minute)
 246   3            {
 247   4              UART_Send_Data(UART0, 'Y');
 248   4              Delay_ms(10);
 249   4              if(rtc_time.seconds >= set_second)
 250   4              {
 251   5                LED_RELAY1 = LOW;         
 252   5                LED_RELAY2 = LOW;
 253   5                state_alram = 0;
 254   5                
 255   5                
 256   5                UART_Send_Data(UART0, 'Z');
 257   5                Delay_ms(10);
 258   5              }
 259   4            }
 260   3          }
 261   2          
 262   2          request_ds1307_interval = LOW;
 263   2        }
 264   1      }
 265          
 266          void parser_data(char *header, char *hours, char *minutes, char *seconds, char *payLoad)
 267          {
 268   1        char *p_rx, *p_header, *p_hours, *p_minutes, *p_seconds;
 269   1        
 270   1        // parser data => $C,23,17,05# - Set current time || $S,23,17,05# - Alarm on || $E,23,17,05# - Alarm off
 271   1        if((header != NULL) && (hours != NULL) && (minutes != NULL) && (seconds != NULL) && (payLoad != NULL))
 272   1        { 
 273   2          p_rx = payLoad;
 274   2          p_header = p_rx;
 275   2          p_rx = strchr(p_header, ',');
 276   2          if(p_rx != NULL)
 277   2          {
 278   3            *p_rx = 0;
 279   3            strcpy(header, p_header);
 280   3          }   
 281   2          
 282   2          p_hours = p_rx+1;
 283   2          p_rx = strchr(p_hours, ',');
 284   2          if(p_rx != NULL)
 285   2          {
 286   3              *p_rx = 0;
 287   3              strcpy(hours, p_hours);
 288   3          }
 289   2          
 290   2          p_minutes = p_rx+1;
 291   2          p_rx = strchr(p_minutes, ',');
 292   2          if(p_rx != NULL)
 293   2          {
 294   3              *p_rx = 0;
 295   3              strcpy(minutes, p_minutes);
 296   3          }
 297   2          
 298   2          p_seconds = p_rx+1;
 299   2          p_rx = strchr(p_seconds, '#');
 300   2          if(p_rx != NULL)
 301   2          {
 302   3              *p_rx = 0;
C51 COMPILER V9.60.0.0   APP                                                               03/13/2023 07:43:08 PAGE 6   

 303   3              strcpy(seconds, p_seconds);
 304   3          }
 305   2        }
 306   1      }
 307          
 308          /*********************************************************************************************************
             -***
 309               Timer1 interrupt subroutine
 310          **********************************************************************************************************
             -**/
 311          void Timer1_ISR (void) interrupt 3
 312          {
 313   1        _push_(SFRS);
 314   1      
 315   1        tick++;
 316   1        if (tick >= 1000) // for 1s
 317   1        {
 318   2          request_ds1307_interval = HIGH;
 319   2          tick = 0;
 320   2        }
 321   1        
 322   1        TH1 = TH1_INIT;
 323   1        TL1 = TL1_INIT;
 324   1        TF0 = 0;
 325   1        
 326   1        _pop_(SFRS);
 327   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1162    ----
   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =     35      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      34
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
