C51 COMPILER V9.60.0.0   APP                                                               03/19/2023 20:01:27 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE APP
OBJECT MODULE PLACED IN .\Objects\app.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\app.c OPTIMIZE(7,SPEED) BROWSE INCDIR(.\inc;.\Library\Device\Include
                    -;.\Library\StdDriver\inc;..\Project) DEBUG OBJECTEXTEND PRINT(.\Listings\app.lst) TABS(2) OBJECT(.\Objects\app.obj)

line level    source

   1          #include "app.h"
   2          
   3          /********************************************//**
   4           *   User variables
   5           ***********************************************/
   6          static unsigned char xdata t_hour_begin = 0, t_minute_begin = 0, t_second_begin = 0;
   7          static unsigned char xdata t_hour_end = 0, t_minute_end = 0, t_second_end = 0;
   8          
   9          // rtc time and date
  10          static RTC_time_t xdata rtc_time;
  11          static RTC_date_t xdata rtc_date;
  12          
  13          // ds1307
  14          volatile uint16_t tick = 0;
  15          volatile unsigned char xdata request_ds1307_interval = LOW;
  16          
  17          // button
  18          static STATE_t xdata state = NORMAL;
  19          
  20          // timer
  21          static unsigned char xdata timer_flag         = FLOATNG;
  22          static unsigned char xdata timer_en_flag      = LOW;
  23          static unsigned char xdata timer_mode_flag    = FLOATNG;
  24          
  25          // uart
  26          char xdata payLoad[PAYLOAD_LEN];
  27          unsigned char xdata index_data = 0;
  28          /********************************************//**
  29           *   User functions
  30           ***********************************************/
  31          void app_init(void)
  32          {
  33   1        MODIFY_HIRC(HIRC_16);
  34   1        
  35   1        // Initialize GPIO
  36   1        GPIO_init();
  37   1        
  38   1        // Initialize UART
  39   1        uart_init();
  40   1        
  41   1        // Initialize delay - timer0
  42   1        Delay_init();
  43   1        
  44   1        // Initialize DS1307
  45   1        DS1307_Init();
  46   1        
  47   1        // Load flash
  48   1        check_btn_last_state();
  49   1        check_timer();
  50   1        
  51   1        // TIMER1 Init 
  52   1        TIM1_init();
  53   1      }
  54          
C51 COMPILER V9.60.0.0   APP                                                               03/19/2023 20:01:27 PAGE 2   

  55          void app_process_action(void)
  56          {
  57   1        check_button();
  58   1      
  59   1        check_uart();
  60   1      
  61   1        check_ds1307();
  62   1      }
  63          
  64          void uart_init(void)
  65          {
  66   1        UART_Open(FREQ_SYS, UART0_Timer3, 9600);
  67   1        ENABLE_UART0_PRINTF;
  68   1        ENABLE_UART0_INTERRUPT;   /* Enable UART0 interrupt */
  69   1        ENABLE_GLOBAL_INTERRUPT;  /* Global interrupt enable */
  70   1      
  71   1        uartFresh();
  72   1      }
  73          
  74          void check_button(void)
  75          {
  76   1        uint16_t timeout = 0, last_state;
  77   1        
  78   1        if (timer_flag == FLOATNG)
  79   1        {
  80   2          if (state == NORMAL)
  81   2          {
  82   3            if(BTN2_PAS == HIGH)
  83   3            {
  84   4              LED_RELAY2 = HIGH;
  85   4              Delay_ms(10);
  86   4              while (BTN2_PAS == HIGH)
  87   4              {
  88   5                if(timeout == 2000)
  89   5                {
  90   6                  LED_RELAY1 = LOW;         
  91   6                  LED_RELAY2 = HIGH;
  92   6                  state = PASS_HOLD_3S;
  93   6                  
  94   6                  last_state = Read_APROM_BYTE(STATE_MODE);
  95   6                  if(last_state != PASS_HOLD_3S)
  96   6                  {
  97   7                    Write_DATAFLASH_BYTE(STATE_MODE, state);
  98   7                  }
  99   6                }
 100   5                Delay_ms(1);
 101   5                timeout++;
 102   5              }
 103   4            }
 104   3            else 
 105   3            {
 106   4              LED_RELAY2 = (BTN1_COS == HIGH)? HIGH : LOW;
 107   4            }
 108   3          }
 109   2          
 110   2          if (state == PASS_HOLD_3S)
 111   2          {
 112   3            if(BTN2_PAS == HIGH)
 113   3            {
 114   4              LED_RELAY1 = HIGH;
 115   4              Delay_ms(10);
 116   4              
C51 COMPILER V9.60.0.0   APP                                                               03/19/2023 20:01:27 PAGE 3   

 117   4              timeout = 0;
 118   4              while (BTN2_PAS == HIGH)
 119   4              {
 120   5                if(timeout == 2000)
 121   5                {
 122   6                  LED_RELAY2 = LOW;
 123   6      
 124   6                  LED_RELAY1 = HIGH;
 125   6                  Delay_ms(100);
 126   6                  LED_RELAY1 = LOW;
 127   6                  Delay_ms(100);
 128   6                  LED_RELAY1 = HIGH;
 129   6      
 130   6                  state = NORMAL;
 131   6      
 132   6                  last_state = Read_APROM_BYTE(STATE_MODE);
 133   6                  if(last_state != NORMAL)
 134   6                  {
 135   7                    Write_DATAFLASH_BYTE(STATE_MODE, state);
 136   7                  }
 137   6                }
 138   5                Delay_ms(1);
 139   5                timeout++;
 140   5              }
 141   4            }
 142   3            else
 143   3            {
 144   4              LED_RELAY1 = 0;
 145   4            }
 146   3          }
 147   2        }
 148   1      }
 149          
 150          void check_btn_last_state(void)
 151          {
 152   1        uint8_t tmp;
 153   1      
 154   1        tmp = Read_APROM_BYTE(STATE_MODE);
 155   1        if(tmp != 0xFF)
 156   1        {
 157   2          state = tmp;
 158   2        }
 159   1      
 160   1        if(state == NORMAL)
 161   1        {
 162   2          LED_RELAY1 = 1;
 163   2          LED_RELAY2 = 0;   
 164   2        }
 165   1        else if (state == PASS_HOLD_3S)
 166   1        {
 167   2          LED_RELAY1 = 0;
 168   2          LED_RELAY2 = 1;   
 169   2        }
 170   1        else 
 171   1        {
 172   2          LED_RELAY1 = 1;
 173   2          LED_RELAY2 = 0;
 174   2        }
 175   1      }
 176          
 177          void check_timer(void)
 178          {
C51 COMPILER V9.60.0.0   APP                                                               03/19/2023 20:01:27 PAGE 4   

 179   1        uint8_t tmp;
 180   1      
 181   1        tmp = Read_APROM_BYTE(DS1307_HOURS_START_ADDRESS);
 182   1        if(tmp != 0xff)
 183   1        {
 184   2          t_hour_begin = tmp;
 185   2        }
 186   1        
 187   1        tmp = Read_APROM_BYTE(DS1307_MINUTE_START_ADDRESS);
 188   1        if(tmp != 0xff)
 189   1        {
 190   2          t_minute_begin = tmp;
 191   2        }
 192   1        
 193   1        tmp = Read_APROM_BYTE(DS1307_SECOND_START_ADDRESS);
 194   1        if(tmp != 0xff)
 195   1        {
 196   2          t_second_begin = tmp;
 197   2        }
 198   1        
 199   1        tmp = Read_APROM_BYTE(DS1307_HOURS_STOP_ADDRESS);
 200   1        if(tmp != 0xff)
 201   1        {
 202   2          t_hour_end = tmp;
 203   2        }
 204   1        
 205   1        tmp = Read_APROM_BYTE(DS1307_MINUTE_STOP_ADDRESS);
 206   1        if(tmp != 0xff)
 207   1        {
 208   2          t_minute_end = tmp;
 209   2        }
 210   1        
 211   1        tmp = Read_APROM_BYTE(DS1307_SECOND_STOP_ADDRESS);
 212   1        if(tmp != 0xff)
 213   1        {
 214   2          t_second_end = tmp;
 215   2        }
 216   1        
 217   1        tmp = Read_APROM_BYTE(DS1307_TIMER_MODE_FLAG);  
 218   1        if(tmp != 0xff)
 219   1        {
 220   2          timer_mode_flag = tmp;
 221   2        }
 222   1        
 223   1        tmp = Read_APROM_BYTE(DS1307_TIMER_FLAG);
 224   1        if(tmp != 0xff)
 225   1        {
 226   2          timer_flag = tmp;
 227   2        }
 228   1        
 229   1        tmp = Read_APROM_BYTE(DS1307_TIMER_EN_FLAG);
 230   1        if(tmp != 0xff)
 231   1        {
 232   2          timer_en_flag = tmp;
 233   2        }
 234   1        
 235   1        if(timer_flag == HIGH)
 236   1        {
 237   2          LED_RELAY1 = HIGH;
 238   2          LED_RELAY2 = LOW;
 239   2        }
 240   1        else if(timer_flag == LOW)
C51 COMPILER V9.60.0.0   APP                                                               03/19/2023 20:01:27 PAGE 5   

 241   1        {
 242   2          LED_RELAY1 = LOW;
 243   2          LED_RELAY2 = LOW;
 244   2        }
 245   1        else 
 246   1        {
 247   2          
 248   2        }
 249   1      }
 250          
 251          void check_uart(void)
 252          {
 253   1        char xdata header[3], hours[3], minutes[3], seconds[3];
 254   1        uint8_t tmp = 0;
 255   1        
 256   1        if (IsData() == '#')
 257   1        {
 258   2          while(IsAvailable()) // read from message header
 259   2          {
 260   3            if (uartReadByte() == '$') 
 261   3            {
 262   4              payLoad[index_data++] = '$';
 263   4              break;
 264   4            }
 265   3          }
 266   2      
 267   2          while(IsAvailable()) // read the message body
 268   2          {
 269   3            payLoad[index_data++] = uartReadByte();
 270   3            if(payLoad[index_data - 1]== '#') break;
 271   3          }
 272   2          payLoad[index_data] = '\0';
 273   2          // clear buffer
 274   2          uartResetNByte(PAYLOAD_LEN);
 275   2          
 276   2          // parser data
 277   2          parser_data(header, hours, minutes, seconds, payLoad);
 278   2          
 279   2          if(!strcmp(header, "$C"))
 280   2          {
 281   3            rtc_time.hours       = atoi(hours);
 282   3            rtc_time.minutes     = atoi(minutes);
 283   3            rtc_time.seconds     = atoi(seconds);
 284   3            DS1307_Set_Current_Time(&rtc_time);
 285   3        
 286   3            printf("OK\r\n");
 287   3          }
 288   2          else if (!strcmp(header, "$S")) // time A
 289   2          {
 290   3            if (timer_en_flag == LOW) // if timer is DISABLE
 291   3            {
 292   4              t_hour_begin     = atoi(hours);
 293   4              t_minute_begin   = atoi(minutes);
 294   4              t_second_begin   = atoi(seconds);
 295   4          
 296   4              Write_DATAFLASH_BYTE(DS1307_HOURS_START_ADDRESS, t_hour_begin);
 297   4              Write_DATAFLASH_BYTE(DS1307_MINUTE_START_ADDRESS, t_minute_begin);
 298   4              Write_DATAFLASH_BYTE(DS1307_SECOND_START_ADDRESS, t_second_begin);  
 299   4      
 300   4              printf("OK\r\n");   
 301   4            }
 302   3            else
C51 COMPILER V9.60.0.0   APP                                                               03/19/2023 20:01:27 PAGE 6   

 303   3            {
 304   4              printf("NOT OK => DURING TIMER\r\n");   
 305   4            }
 306   3          }
 307   2          else if (!strcmp(header, "$E")) // time B
 308   2          {
 309   3            if (timer_en_flag == LOW) // if timer is DISABLE
 310   3            {
 311   4              t_hour_end     = atoi(hours);
 312   4              t_minute_end   = atoi(minutes);
 313   4              t_second_end   = atoi(seconds);
 314   4          
 315   4              Write_DATAFLASH_BYTE(DS1307_HOURS_STOP_ADDRESS, t_hour_end);
 316   4              Write_DATAFLASH_BYTE(DS1307_MINUTE_STOP_ADDRESS, t_minute_end);
 317   4              Write_DATAFLASH_BYTE(DS1307_SECOND_STOP_ADDRESS, t_second_end);     
 318   4      
 319   4              printf("OK\r\n");
 320   4            }
 321   3            else
 322   3            {
 323   4              printf("NOT OK => DURING TIMER\r\n");
 324   4            }
 325   3          }
 326   2          else if (!strcmp(header, "$A")) // enable/disable timer
 327   2          {
 328   3            uint8_t val_1, val_2, val_3;
 329   3            
 330   3            val_1   = atoi(hours);
 331   3            val_2   = atoi(minutes);
 332   3            val_3   = atoi(seconds);
 333   3            
 334   3            if((val_1 == 0) && (val_2 == 0) && (val_3 == 0))
 335   3            {
 336   4              tmp = Read_APROM_BYTE(DS1307_LED_STATUS_TIMER);
 337   4              if((tmp != 0xff) && (timer_en_flag == HIGH))
 338   4              {
 339   5                state = tmp;
 340   5                Write_DATAFLASH_BYTE(STATE_MODE, state);
 341   5              }
 342   4              
 343   4              timer_en_flag = LOW;
 344   4              timer_flag = FLOATNG;
 345   4              
 346   4              Write_DATAFLASH_BYTE(DS1307_TIMER_FLAG, timer_flag);
 347   4              Write_DATAFLASH_BYTE(DS1307_TIMER_EN_FLAG, timer_en_flag);
 348   4              
 349   4              check_btn_last_state();
 350   4              
 351   4              printf("DISABLE\r\n");
 352   4            }
 353   3            else if((val_1 == 11) && (val_2 == 11) && (val_3 == 11))
 354   3            {
 355   4              timer_en_flag = HIGH;
 356   4              timer_flag = LOW;
 357   4              
 358   4              Write_DATAFLASH_BYTE(DS1307_TIMER_FLAG, timer_flag);
 359   4              Write_DATAFLASH_BYTE(DS1307_TIMER_EN_FLAG, timer_en_flag);
 360   4              
 361   4              printf("ENABLE\r\n");
 362   4            }
 363   3          }
 364   2          else
C51 COMPILER V9.60.0.0   APP                                                               03/19/2023 20:01:27 PAGE 7   

 365   2          {
 366   3            // do something here
 367   3          }
 368   2          
 369   2          // clear buffer
 370   2          index_data = 0;
 371   2          memset(payLoad, 0, PAYLOAD_LEN);
 372   2        }
 373   1      }
 374          
 375          void parser_data(char *header, char *hours, char *minutes, char *seconds, char *payLoad)
 376          {
 377   1        char *p_rx, *p_header, *p_hours, *p_minutes, *p_seconds;
 378   1        
 379   1        // parser data => $C,23,17,05# - Set current time || $S,23,17,05# - Alarm on || $E,23,17,05# - Alarm off
 380   1        if((header != NULL) && (hours != NULL) && (minutes != NULL) && (seconds != NULL) && (payLoad != NULL))
 381   1        {
 382   2          p_rx = payLoad;
 383   2          p_header = p_rx;
 384   2          p_rx = strchr(p_header, ',');
 385   2          if(p_rx != NULL)
 386   2          {
 387   3            *p_rx = 0;
 388   3            strcpy(header, p_header);
 389   3          }   
 390   2          
 391   2          p_hours = p_rx+1;
 392   2          p_rx = strchr(p_hours, ',');
 393   2          if(p_rx != NULL)
 394   2          {
 395   3              *p_rx = 0;
 396   3              strcpy(hours, p_hours);
 397   3          }
 398   2          
 399   2          p_minutes = p_rx+1;
 400   2          p_rx = strchr(p_minutes, ',');
 401   2          if(p_rx != NULL)
 402   2          {
 403   3              *p_rx = 0;
 404   3              strcpy(minutes, p_minutes);
 405   3          }
 406   2          
 407   2          p_seconds = p_rx+1;
 408   2          p_rx = strchr(p_seconds, '#');
 409   2          if(p_rx != NULL)
 410   2          {
 411   3              *p_rx = 0;
 412   3              strcpy(seconds, p_seconds);
 413   3          }
 414   2        }
 415   1      }
 416          
 417          void check_ds1307(void)
 418          {
 419   1        if(request_ds1307_interval == HIGH) // ds1307 get interval data
 420   1        {
 421   2          if (timer_en_flag == HIGH) // if timer is ENABLE
 422   2          {
 423   3            // get current time
 424   3            DS1307_Get_Current_Time(&rtc_time);
 425   3      
 426   3            // get current date
C51 COMPILER V9.60.0.0   APP                                                               03/19/2023 20:01:27 PAGE 8   

 427   3            DS1307_Get_Current_Date(&rtc_date);
 428   3      
 429   3            if(timer_flag == LOW) // Phase 1 during A - B
 430   3            {
 431   4              if(TIME2SECOND(t_hour_begin, t_minute_begin, t_second_begin) == TIME2SECOND(t_hour_end, t_minute_end, 
             -t_second_end))
 432   4              {
 433   5                timer_flag = FLOATNG;
 434   5                Write_DATAFLASH_BYTE(DS1307_TIMER_FLAG, timer_flag);
 435   5                
 436   5                printf("SET TIMER ERROR\r\n");
 437   5              }
 438   4              
 439   4              // relay 1 on and relay 2 off => 6.am - 17.pm
 440   4              if(TIME2SECOND(t_hour_begin, t_minute_begin, t_second_begin) < TIME2SECOND(t_hour_end, t_minute_end, t
             -_second_end))
 441   4              {
 442   5      #if LOG_DEBUG
 443   5                printf("1\r\n");
 444   5      #endif
 445   5                if((TIME2SECOND(rtc_time.hours, rtc_time.minutes, rtc_time.seconds) > TIME2SECOND(t_hour_begin, t_min
             -ute_begin, t_second_begin)) &&
 446   5                   (TIME2SECOND(rtc_time.hours, rtc_time.minutes, rtc_time.seconds) < TIME2SECOND(t_hour_end, t_minute
             -_end, t_second_end)))
 447   5                {
 448   6                  LED_RELAY1 = HIGH;
 449   6                  LED_RELAY2 = LOW;
 450   6                  
 451   6                  timer_flag = FLOATNG;
 452   6                  timer_mode_flag = LINE_TIME;
 453   6                  
 454   6                  Write_DATAFLASH_BYTE(DS1307_TIMER_FLAG, timer_flag);
 455   6                  Write_DATAFLASH_BYTE(DS1307_TIMER_MODE_FLAG, timer_mode_flag);
 456   6                  
 457   6                  check_btn_last_state();
 458   6                  
 459   6                  if((LED_RELAY1 != HIGH) && (LED_RELAY2 != LOW))
 460   6                  {
 461   7                    LED_RELAY1 = HIGH;
 462   7                    LED_RELAY2 = LOW;
 463   7                    
 464   7                    Write_DATAFLASH_BYTE(STATE_MODE, NORMAL);
 465   7                    Write_DATAFLASH_BYTE(DS1307_LED_STATUS_TIMER, state);
 466   7                    state = NORMAL;
 467   7                  }
 468   6      #if LOG_DEBUG
 469   6                  printf("Jump into active mode 1\r\n");
 470   6      #endif
 471   6                }
 472   5              }
 473   4              
 474   4              // relay 1 on and relay 2 off => 19.pm - 6.am
 475   4              if(TIME2SECOND(t_hour_begin, t_minute_begin, t_second_begin) > TIME2SECOND(t_hour_end, t_minute_end, t
             -_second_end))
 476   4              {
 477   5      #if LOG_DEBUG
 478   5                printf("2\r\n");
 479   5      #endif
 480   5                if(TIME2SECOND(rtc_time.hours, rtc_time.minutes, rtc_time.seconds) > TIME2SECOND(t_hour_begin, t_minu
             -te_begin, t_second_begin))
 481   5                {
 482   6                  LED_RELAY1 = HIGH;
C51 COMPILER V9.60.0.0   APP                                                               03/19/2023 20:01:27 PAGE 9   

 483   6                  LED_RELAY2 = LOW;
 484   6                  
 485   6                  timer_flag = FLOATNG;
 486   6                  timer_mode_flag = WRAP_TIME;
 487   6                  
 488   6                  Write_DATAFLASH_BYTE(DS1307_TIMER_FLAG, timer_flag);
 489   6                  Write_DATAFLASH_BYTE(DS1307_TIMER_MODE_FLAG, timer_mode_flag);
 490   6            
 491   6                  check_btn_last_state();
 492   6                  
 493   6                  if((LED_RELAY1 != HIGH) && (LED_RELAY2 != LOW))
 494   6                  {
 495   7                    LED_RELAY1 = HIGH;
 496   7                    LED_RELAY2 = LOW;
 497   7                    
 498   7                    Write_DATAFLASH_BYTE(STATE_MODE, NORMAL);
 499   7                    Write_DATAFLASH_BYTE(DS1307_LED_STATUS_TIMER, state);
 500   7                    state = NORMAL;
 501   7                  }
 502   6      #if LOG_DEBUG
 503   6                  printf("Jump into active mode 2\r\n");
 504   6      #endif
 505   6                }
 506   5              }
 507   4            }
 508   3            
 509   3            if(timer_flag == FLOATNG) // Phase 2 during A - B
 510   3            {
 511   4              // relay 1 and relay 2 off => 6.am - 17.pm
 512   4              if((TIME2SECOND(t_hour_begin, t_minute_begin, t_second_begin) < TIME2SECOND(t_hour_end, t_minute_end, 
             -t_second_end)) &&
 513   4                 (timer_mode_flag == LINE_TIME))
 514   4              {
 515   5      #if LOG_DEBUG
 516   5                printf("12\r\n");
 517   5      #endif
 518   5                if(TIME2SECOND(rtc_time.hours, rtc_time.minutes, rtc_time.seconds) < TIME2SECOND(t_hour_begin, t_min
             -ute_begin, t_second_begin))
 519   5                {
 520   6                  LED_RELAY1 = LOW;
 521   6                  LED_RELAY2 = LOW;
 522   6                  
 523   6                  timer_flag = LOW;
 524   6                  timer_mode_flag = FLOATNG;
 525   6                  
 526   6                  Write_DATAFLASH_BYTE(DS1307_TIMER_FLAG, timer_flag);
 527   6                  Write_DATAFLASH_BYTE(DS1307_TIMER_MODE_FLAG, timer_mode_flag);
 528   6      #if LOG_DEBUG           
 529   6                  printf("Jump out active mode 1 < \r\n");
 530   6      #endif
 531   6                }
 532   5      
 533   5                if(TIME2SECOND(rtc_time.hours, rtc_time.minutes, rtc_time.seconds) > TIME2SECOND(t_hour_end, t_minute
             -_end, t_second_end))
 534   5                {
 535   6                  LED_RELAY1 = LOW;
 536   6                  LED_RELAY2 = LOW;
 537   6                  
 538   6                  timer_flag = LOW;
 539   6                  timer_mode_flag = FLOATNG;
 540   6      
 541   6                  Write_DATAFLASH_BYTE(DS1307_TIMER_FLAG, timer_flag);
C51 COMPILER V9.60.0.0   APP                                                               03/19/2023 20:01:27 PAGE 10  

 542   6                  Write_DATAFLASH_BYTE(DS1307_TIMER_MODE_FLAG, timer_mode_flag);
 543   6      #if LOG_DEBUG           
 544   6                  printf("Jump out active mode 1 > \r\n");
 545   6      #endif
 546   6                }
 547   5              }
 548   4              
 549   4              // relay 1 and relay 2 off => 19.pm - 6.am
 550   4              if((TIME2SECOND(t_hour_begin, t_minute_begin, t_second_begin) > TIME2SECOND(t_hour_end, t_minute_end, 
             -t_second_end)) &&
 551   4                 (timer_mode_flag == WRAP_TIME))
 552   4              {
 553   5      #if LOG_DEBUG 
 554   5                printf("21\r\n"); 
 555   5      #endif
 556   5                if((TIME2SECOND(rtc_time.hours, rtc_time.minutes, rtc_time.seconds) < TIME2SECOND(t_hour_begin, t_min
             -ute_begin, t_second_begin)) && // 6.am -> 19.pm
 557   5                   (TIME2SECOND(rtc_time.hours, rtc_time.minutes, rtc_time.seconds) > TIME2SECOND(t_hour_end, t_minute
             -_end, t_second_end)))
 558   5                {
 559   6                  LED_RELAY1 = LOW;
 560   6                  LED_RELAY2 = LOW;
 561   6                  
 562   6                  timer_flag = LOW;
 563   6                  timer_mode_flag = FLOATNG;
 564   6                  
 565   6                  Write_DATAFLASH_BYTE(DS1307_TIMER_FLAG, timer_flag);
 566   6                  Write_DATAFLASH_BYTE(DS1307_TIMER_MODE_FLAG, timer_mode_flag);
 567   6      #if LOG_DEBUG             
 568   6                  printf("Jump out active mode 2\r\n");
 569   6      #endif
 570   6                }         
 571   5              }
 572   4            }
 573   3          }
 574   2          
 575   2          request_ds1307_interval = LOW;
 576   2        }
 577   1      }
 578          
 579          /*********************************************************************************************************
             -***
 580               Timer1 interrupt subroutine
 581          **********************************************************************************************************
             -**/
 582          void Timer1_ISR (void) interrupt 3
 583          {
 584   1        _push_(SFRS);
 585   1      
 586   1        tick++;
 587   1        if (tick >= 1000) // for 1s
 588   1        {
 589   2          request_ds1307_interval = HIGH;
 590   2          tick = 0;
 591   2        }
 592   1        
 593   1        TH1 = TH1_INIT;
 594   1        TL1 = TL1_INIT;
 595   1        TF0 = 0;
 596   1        
 597   1        _pop_(SFRS);
 598   1      }
C51 COMPILER V9.60.0.0   APP                                                               03/19/2023 20:01:27 PAGE 11  



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4314    ----
   CONSTANT SIZE    =    230    ----
   XDATA SIZE       =     33      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      38
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
